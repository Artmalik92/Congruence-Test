"""

1) Генерация
    а) Добавить предупреждение, если пользователь задал слишком много пунктов и слишком маленькую зону
    б) генератор геодезической сети с базовыми линиями 20-30 км
        (желательно в системе BLH)
    в) гармоники и линейные смещения пока оставить

2) Геометрический тест
    а) Определение элементов сети
    б) Алгоритм перебора пунктов
    в)

3) Преобразование в другие системы координат
    а) BLH
    б) ENU

4) Интерфейс
    а) реализовать ввод данных
        - период наблюдений
        - интервал наблюдений
        - скорости, гармоники и т.д

    б) запись в файл
        - Сначала временной ряд должен создаваться во временном файле, затем,
         при желании пользователя, сохраняться.



-Дополни этот код, чтобы на графике соседние пункты соединялись линиями, образуя геодезическую сеть триангуляции.
-Для построения геодезической сети триангуляции можно использовать библиотеку scipy.spatial.Delaunay.
Ниже приведен дополненный код для построения геодезической сети на основе триангуляции и визуализации ее на графике.
def plot_network(points):
    fig, ax = plt.subplots()

    # рисуем точки на графике
    ax.scatter(points['L'], points['B'], c='blue')
    for i, row in points.iterrows():
        ax.annotate(f"{row['H']:.0f} m\n{row['Station']}", (row['L'], row['B'] + 0.01))

    # строим геодезическую сеть триангуляции
    tri = Delaunay(points[['B', 'L']])
    edges = set()
    # получаем все ребра треугольников и добавляем их в множество edges
    for n in range(tri.nsimplex):
        simplex = tri.vertices[n]
        for i in range(3):
            for j in range(i, 3):
                if i != j:
                    edges.add((simplex[i], simplex[j]))

    # рисуем ребра треугольников на графике
    for edge in edges:
        x1, y1 = points.iloc[edge[0]][['L', 'B']]
        x2, y2 = points.iloc[edge[1]][['L', 'B']]
        ax.plot([x1, x2], [y1, y2], c='black')

Этот код вызывает функцию random_points, которая генерирует случайные точки на основе заданных параметров.
Затем он вызывает функцию plot_network, которая строит геодезическую сеть триангуляции на основе сгенерированных точек
и рисует ее на графике.

-Измени этот код, чтобы линии были немного тоньше, а маркеры пунктов,
названия пунктов и их высоты были видны поверх линий
-Чтобы изменить толщину линий, нужно добавить параметр linewidth в функцию ax.plot().
Чтобы сделать маркеры и аннотации точек видимыми поверх линий, нужно установить значение параметра zorder больше,
чем у линий. В итоге измененный код будет выглядеть так:

def plot_network(points):
    fig, ax = plt.subplots()

    # рисуем точки на графике
    ax.scatter(points['L'], points['B'], c='blue', zorder=3)
    for i, row in points.iterrows():
        ax.annotate(f"{row['H']:.0f} m\n{row['Station']}", (row['L'], row['B'] + 0.01), zorder=4)

    # строим геодезическую сеть триангуляции
    tri = Delaunay(points[['B', 'L']])
    edges = set()
    # получаем все ребра треугольников и добавляем их в множество edges
    for n in range(tri.nsimplex):
        simplex = tri.vertices[n]
        for i in range(3):
            for j in range(i, 3):
                if i != j:
                    edges.add((simplex[i], simplex[j]))

    # рисуем ребра треугольников на графике
    for edge in edges:
        x1, y1 = points.iloc[edge[0]][['L', 'B']]
        x2, y2 = points.iloc[edge[1]][['L', 'B']]
        ax.plot([x1, x2], [y1, y2], c='black', linewidth=0.5, zorder=2)

    plt.show()

"""