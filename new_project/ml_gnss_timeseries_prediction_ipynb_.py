# -*- coding: utf-8 -*-
"""Копия блокнота "ML_GNSS_TimeSeries_Prediction.ipynb"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iPQ3R3DJoayjoXbVA1mwkBGfYyMOy8YZ
"""

import sqlite3
import pandas as pd
from google.colab import drive

import numpy as np
from numpy.linalg import pinv
from scipy.stats import chi2

#подключение к БД через Гугл-диск
cnx = sqlite3.connect('/content/drive/MyDrive/ForCoding/fags_ppp_timeseries.sqlite3') 
df = pd.read_sql_query("SELECT * FROM mark_coordinate", cnx)
df= df.set_index('code')
#выбор пункта наблюдений на две произвольные даты, где одна эпоха начальная

timeserie=df.loc[['NOVM', 'NVSK','NSK1']]
timeserie=timeserie.set_index('epoch')
timeserie_base=timeserie.loc['2015-01-01 11:57:30']
timeserie_i=timeserie.loc['2015-01-07 11:57:30']

print(timeserie_i)
print(timeserie_base)

#функция для формирования вектора координат на выбранную эпоху 
def L_array (DataFrame_array):
    L=np.zeros((9))
    for i in range (3):
        K=DataFrame_array.iloc[i].loc[['X','Y','Z']].to_numpy()
        for j in range (3):
            L[3*i]=K[0]
            L[3*i+1]=K[1]
            L[3*i+2]=K[2]
    return L
    print(L)
#вычисление вектора разности
d=L_array (timeserie_i)-L_array (timeserie_base)
print(d)

# код теста стабильности из Journal of Applied Geodesy 1 (2007), 1–7 6 de Gruyter 2007. DOI 10.1515/JAG.2007.001
Qdd=np.eye(9)                                                     # пока вместо ковариационной матрицы - еденичная
sigma_0=0.005                                                          # СКП еденицы веса, как я понял . пока задам руками
K=d.transpose().dot(pinv(Qdd)).dot(d)/(sigma_0**2) # статистика для теста хи квадрат  гипотеза такая: математическое ожидание от вектора разностей координаты нулевое
print(K)

Qdd=np.eye(9)                                                     # пока вместо ковариационной матрицы - еденичная
sigma_0=0.005                                                          # СКП еденицы веса, как я понял . пока задам руками
K=d.transpose().dot(pinv(Qdd)).dot(d)/(sigma_0**2) # статистика для теста хи квадрат  гипотеза такая: математическое ожидание от вектора разностей координаты нулевое
print(K)

# проверка статистической гипотезы

test_value=chi2.ppf(df=d.shape[0],q=0.05) # значение функции хм квадрат при заданном уровне доверительной вероятности 0.05

if K>test_value:
    print('null hipotesis is rejected' )
else:
    print('null hipotesis is not rejected ')

#формирование Матриц коэффициентов
A2=np.zeros((nsite, L.shape[0]))
for i in range(3):
    A2[i,3*i]=L[i*3]/abs(L[3*i])
    A2[i,3*i+1]=L[i*3+1]/abs(L[3*i+1])
    A2[i,3*i+2]=L[i*3+1]/abs(L[3*i+1])
print(A2)

#матрица А
A1=np.array([[1,0,0,-1,0,0,0,0,0],[0,1,0,0,-1,0,0,0,0],

             [0,0,1,0,0,-1,0,0,0],
             [0,0,0,1,0,0,-1,0,0],
             [0,0,0,0,1,0,0,-1,0],
             [0,0,0,0,0,1,0,0,-1],
             [-1,0,0,0,0,0,1,0,0],
             [0,-1,0,0,0,0,0,1,0],
             [0,0,-1,0,0,0,0,0,1]])

print(A1)
A1.shape

A3=np.linalg.pinv(A2 )
Q =np.eye(9)
P=np.linalg.inv(Q )
A=A1.dot(A2 )

N=A.transpose().dot(Q ).dot(A )
x=np.linalg.pinv(N ).dot(A.transpose()).dot(P ).dot(L )
x
v=A.dot(x )-L

Qvv=Q-A.dot(np.linalg.pinv(A.transpose().dot(P ).dot(A ))).dot(A.transpose())
vv=-Qvv.dot(P ).dot(L )
vv

N=-A1.transpose().dot(A1 )
X=np.linalg.pinv(N ).dot(A1.transpose().dot(L ))
Z=X[0]+X[1]+X[2]
V=A1.dot(X)
Z